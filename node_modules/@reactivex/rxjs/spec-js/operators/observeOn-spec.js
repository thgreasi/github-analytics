"use strict";
var Rx = require('../../dist/cjs/Rx');
var chai_1 = require('chai');
var Observable = Rx.Observable;
/** @test {observeOn} */
describe('Observable.prototype.observeOn', function () {
    asDiagram('observeOn(scheduler)')('should observe on specified scheduler', function () {
        var e1 = hot('--a--b--|');
        var expected = '--a--b--|';
        var sub = '^       !';
        expectObservable(e1.observeOn(rxTestScheduler)).toBe(expected);
        expectSubscriptions(e1.subscriptions).toBe(sub);
    });
    it('should observe after specified delay', function () {
        var e1 = hot('--a--b--|');
        var expected = '-----a--b--|';
        var sub = '^          !';
        expectObservable(e1.observeOn(rxTestScheduler, 30)).toBe(expected);
        expectSubscriptions(e1.subscriptions).toBe(sub);
    });
    it('should observe when source raises error', function () {
        var e1 = hot('--a--#');
        var expected = '--a--#';
        var sub = '^    !';
        expectObservable(e1.observeOn(rxTestScheduler)).toBe(expected);
        expectSubscriptions(e1.subscriptions).toBe(sub);
    });
    it('should observe when source is empty', function () {
        var e1 = hot('-----|');
        var expected = '-----|';
        var sub = '^    !';
        expectObservable(e1.observeOn(rxTestScheduler)).toBe(expected);
        expectSubscriptions(e1.subscriptions).toBe(sub);
    });
    it('should observe when source does not complete', function () {
        var e1 = hot('-----');
        var expected = '-----';
        var sub = '^    ';
        expectObservable(e1.observeOn(rxTestScheduler)).toBe(expected);
        expectSubscriptions(e1.subscriptions).toBe(sub);
    });
    it('should allow unsubscribing early and explicitly', function () {
        var e1 = hot('--a--b--|');
        var sub = '^   !    ';
        var expected = '--a--    ';
        var unsub = '    !    ';
        var result = e1.observeOn(rxTestScheduler);
        expectObservable(result, unsub).toBe(expected);
        expectSubscriptions(e1.subscriptions).toBe(sub);
    });
    it('should not break unsubscription chains when the result is unsubscribed explicitly', function () {
        var e1 = hot('--a--b--|');
        var sub = '^   !    ';
        var expected = '--a--    ';
        var unsub = '    !    ';
        var result = e1
            .mergeMap(function (x) { return Observable.of(x); })
            .observeOn(rxTestScheduler)
            .mergeMap(function (x) { return Observable.of(x); });
        expectObservable(result, unsub).toBe(expected);
        expectSubscriptions(e1.subscriptions).toBe(sub);
    });
    it('should clean up subscriptions created by async scheduling (prevent memory leaks #2244)', function (done) {
        //HACK: Deep introspection to make sure we're cleaning up notifications in scheduling.
        // as the architecture changes, this test may become brittle.
        var results = [];
        // This is to build a scheduled observable with a slightly more stable
        // subscription structure, since we're going to hack in to analyze it in this test.
        var subscription = new Observable(function (observer) {
            var i = 1;
            return Rx.Scheduler.asap.schedule(function () {
                if (i > 3) {
                    observer.complete();
                }
                else {
                    observer.next(i++);
                    this.schedule();
                }
            });
        })
            .observeOn(Rx.Scheduler.asap)
            .subscribe(function (x) {
            var observeOnSubscriber = subscription._subscriptions[0];
            chai_1.expect(observeOnSubscriber._subscriptions.length).to.equal(2); // 1 for the consumer, and one for the notification
            chai_1.expect(observeOnSubscriber._subscriptions[1].state.notification.kind)
                .to.equal('N');
            chai_1.expect(observeOnSubscriber._subscriptions[1].state.notification.value)
                .to.equal(x);
            results.push(x);
        }, function (err) { return done(err); }, function () {
            // now that the last nexted value is done, there should only be a complete notification scheduled
            var observeOnSubscriber = subscription._subscriptions[0];
            chai_1.expect(observeOnSubscriber._subscriptions.length).to.equal(2); // 1 for the consumer, one for the complete notification
            // only this completion notification should remain.
            chai_1.expect(observeOnSubscriber._subscriptions[1].state.notification.kind)
                .to.equal('C');
            // After completion, the entire _subscriptions list is nulled out anyhow, so we can't test much further than this.
            chai_1.expect(results).to.deep.equal([1, 2, 3]);
            done();
        });
    });
});
//# sourceMappingURL=observeOn-spec.js.map