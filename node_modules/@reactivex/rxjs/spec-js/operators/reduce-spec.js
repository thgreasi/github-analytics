"use strict";
var chai_1 = require('chai');
var Rx = require('../../dist/cjs/Rx');
var Observable = Rx.Observable;
/** @test {reduce} */
describe('Observable.prototype.reduce', function () {
    asDiagram('reduce((acc, curr) => acc + curr, 0)')('should reduce', function () {
        var values = {
            a: 1, b: 3, c: 5, x: 9
        };
        var e1 = hot('--a--b--c--|', values);
        var e1subs = '^          !';
        var expected = '-----------(x|)';
        var reduceFunction = function (o, x) {
            return o + x;
        };
        expectObservable(e1.reduce(reduceFunction, 0)).toBe(expected, values);
        expectSubscriptions(e1.subscriptions).toBe(e1subs);
    });
    it('should reduce with seed', function () {
        var e1 = hot('--a--b--|');
        var e1subs = '^       !';
        var expected = '--------(x|)';
        var seed = 'n';
        var reduceFunction = function (o, x) {
            return o + x;
        };
        expectObservable(e1.reduce(reduceFunction, seed)).toBe(expected, { x: seed + 'ab' });
        expectSubscriptions(e1.subscriptions).toBe(e1subs);
    });
    it('should reduce with a seed of undefined', function () {
        var e1 = hot('--a--^--b--c--d--e--f--g--|');
        var e1subs = '^                    !';
        var expected = '---------------------(x|)';
        var values = {
            x: 'undefined b c d e f g'
        };
        var source = e1.reduce(function (acc, x) { return acc + ' ' + x; }, undefined);
        expectObservable(source).toBe(expected, values);
        expectSubscriptions(e1.subscriptions).toBe(e1subs);
    });
    it('should reduce without a seed', function () {
        var e1 = hot('--a--^--b--c--d--e--f--g--|');
        var e1subs = '^                    !';
        var expected = '---------------------(x|)';
        var values = {
            x: 'b c d e f g'
        };
        var source = e1.reduce(function (acc, x) { return acc + ' ' + x; });
        expectObservable(source).toBe(expected, values);
        expectSubscriptions(e1.subscriptions).toBe(e1subs);
    });
    it('should reduce with index without seed', function (done) {
        var idx = [1, 2, 3, 4, 5];
        Observable.range(0, 6).reduce(function (acc, value, index) {
            chai_1.expect(idx.shift()).to.equal(index);
            return value;
        }).subscribe(null, null, function () {
            chai_1.expect(idx).to.be.empty;
            done();
        });
    });
    it('should reduce with index with seed', function (done) {
        var idx = [0, 1, 2, 3, 4, 5];
        Observable.range(0, 6).reduce(function (acc, value, index) {
            chai_1.expect(idx.shift()).to.equal(index);
            return value;
        }, -1).subscribe(null, null, function () {
            chai_1.expect(idx).to.be.empty;
            done();
        });
    });
    it('should reduce with seed if source is empty', function () {
        var e1 = hot('--a--^-------|');
        var e1subs = '^       !';
        var expected = '--------(x|)';
        var expectedValue = '42';
        var reduceFunction = function (o, x) {
            return o + x;
        };
        expectObservable(e1.reduce(reduceFunction, expectedValue)).toBe(expected, { x: expectedValue });
        expectSubscriptions(e1.subscriptions).toBe(e1subs);
    });
    it('should raise error if reduce function throws without seed', function () {
        var e1 = hot('--a--b--|');
        var e1subs = '^    !   ';
        var expected = '-----#   ';
        var reduceFunction = function (o, x) {
            throw 'error';
        };
        expectObservable(e1.reduce(reduceFunction)).toBe(expected);
        expectSubscriptions(e1.subscriptions).toBe(e1subs);
    });
    it('should allow unsubscribing explicitly and early', function () {
        var e1 = hot('--a--b--|');
        var unsub = '      !  ';
        var e1subs = '^     !  ';
        var expected = '-------  ';
        var reduceFunction = function (o, x) {
            return o + x;
        };
        var result = e1.reduce(reduceFunction);
        expectObservable(result, unsub).toBe(expected);
        expectSubscriptions(e1.subscriptions).toBe(e1subs);
    });
    it('should not break unsubscription chains when result is unsubscribed explicitly', function () {
        var e1 = hot('--a--b--|');
        var e1subs = '^     !  ';
        var expected = '-------  ';
        var unsub = '      !  ';
        var reduceFunction = function (o, x) {
            return o + x;
        };
        var result = e1
            .mergeMap(function (x) { return Observable.of(x); })
            .reduce(reduceFunction)
            .mergeMap(function (x) { return Observable.of(x); });
        expectObservable(result, unsub).toBe(expected);
        expectSubscriptions(e1.subscriptions).toBe(e1subs);
    });
    it('should raise error if source emits and raises error with seed', function () {
        var e1 = hot('--a--b--#');
        var e1subs = '^       !';
        var expected = '--------#';
        var expectedValue = '42';
        var reduceFunction = function (o, x) {
            return o + x;
        };
        expectObservable(e1.reduce(reduceFunction, expectedValue)).toBe(expected);
        expectSubscriptions(e1.subscriptions).toBe(e1subs);
    });
    it('should raise error if source raises error with seed', function () {
        var e1 = hot('----#');
        var e1subs = '^   !';
        var expected = '----#';
        var expectedValue = '42';
        var reduceFunction = function (o, x) {
            return o + x;
        };
        expectObservable(e1.reduce(reduceFunction, expectedValue)).toBe(expected);
        expectSubscriptions(e1.subscriptions).toBe(e1subs);
    });
    it('should raise error if reduce function throws with seed', function () {
        var e1 = hot('--a--b--|');
        var e1subs = '^ !     ';
        var expected = '--#     ';
        var seed = 'n';
        var reduceFunction = function (o, x) {
            throw 'error';
        };
        expectObservable(e1.reduce(reduceFunction, seed)).toBe(expected);
        expectSubscriptions(e1.subscriptions).toBe(e1subs);
    });
    it('should not complete with seed if source emits but does not completes', function () {
        var e1 = hot('--a--');
        var e1subs = '^    ';
        var expected = '-----';
        var seed = 'n';
        var reduceFunction = function (o, x) {
            return o + x;
        };
        expectObservable(e1.reduce(reduceFunction, seed)).toBe(expected);
        expectSubscriptions(e1.subscriptions).toBe(e1subs);
    });
    it('should not complete with seed if source never completes', function () {
        var e1 = cold('-');
        var e1subs = '^';
        var expected = '-';
        var seed = 'n';
        var reduceFunction = function (o, x) {
            return o + x;
        };
        expectObservable(e1.reduce(reduceFunction, seed)).toBe(expected);
        expectSubscriptions(e1.subscriptions).toBe(e1subs);
    });
    it('should not complete without seed if source emits but does not completes', function () {
        var e1 = hot('--a--b--');
        var e1subs = '^       ';
        var expected = '--------';
        var reduceFunction = function (o, x) {
            return o + x;
        };
        expectObservable(e1.reduce(reduceFunction)).toBe(expected);
        expectSubscriptions(e1.subscriptions).toBe(e1subs);
    });
    it('should not complete without seed if source never completes', function () {
        var e1 = cold('-');
        var e1subs = '^';
        var expected = '-';
        var reduceFunction = function (o, x) {
            return o + x;
        };
        expectObservable(e1.reduce(reduceFunction)).toBe(expected);
        expectSubscriptions(e1.subscriptions).toBe(e1subs);
    });
    it('should reduce if source does not emit without seed', function () {
        var e1 = hot('--a--^-------|');
        var e1subs = '^       !';
        var expected = '--------|';
        var reduceFunction = function (o, x) {
            return o + x;
        };
        expectObservable(e1.reduce(reduceFunction)).toBe(expected);
        expectSubscriptions(e1.subscriptions).toBe(e1subs);
    });
    it('should raise error if source emits and raises error without seed', function () {
        var e1 = hot('--a--b--#');
        var e1subs = '^       !';
        var expected = '--------#';
        var reduceFunction = function (o, x) {
            return o + x;
        };
        expectObservable(e1.reduce(reduceFunction)).toBe(expected);
        expectSubscriptions(e1.subscriptions).toBe(e1subs);
    });
    it('should raise error if source raises error without seed', function () {
        var e1 = hot('----#');
        var e1subs = '^   !';
        var expected = '----#';
        var reduceFunction = function (o, x) {
            return o + x;
        };
        expectObservable(e1.reduce(reduceFunction)).toBe(expected);
        expectSubscriptions(e1.subscriptions).toBe(e1subs);
    });
    it('should accept array typed reducers', function () {
        type(function () {
            var a;
            a.reduce(function (acc, value) { return acc.concat(value); }, []);
        });
    });
    it('should accept T typed reducers', function () {
        type(function () {
            var a;
            var reduced = a.reduce(function (acc, value) {
                value.a = acc.a;
                value.b = acc.b;
                return acc;
            });
            reduced.subscribe(function (r) {
                r.a.toExponential();
                r.b.toLowerCase();
            });
        });
    });
    it('should accept R typed reducers when R is assignable to T', function () {
        type(function () {
            var a;
            var reduced = a.reduce(function (acc, value) {
                value.a = acc.a;
                value.b = acc.b;
                return acc;
            }, {});
            reduced.subscribe(function (r) {
                r.a.toExponential();
                r.b.toLowerCase();
            });
        });
    });
    it('should accept R typed reducers when R is not assignable to T', function () {
        type(function () {
            var a;
            var seed = {
                as: [1],
                bs: ['a']
            };
            var reduced = a.reduce(function (acc, value) {
                acc.as.push(value.a);
                acc.bs.push(value.b);
                return acc;
            }, seed);
            reduced.subscribe(function (r) {
                r.as[0].toExponential();
                r.bs[0].toLowerCase();
            });
        });
    });
    it('should accept R typed reducers and reduce to type R', function () {
        type(function () {
            var a;
            var reduced = a.reduce(function (acc, value) {
                value.a = acc.a;
                value.b = acc.b;
                return acc;
            }, {});
            reduced.subscribe(function (r) {
                r.a.toExponential();
                r.b.toLowerCase();
            });
        });
    });
    it('should accept array of R typed reducers and reduce to array of R', function () {
        type(function () {
            var a;
            var reduced = a.reduce(function (acc, cur) {
                console.log(acc);
                acc.push(cur.toString());
                return acc;
            }, []);
            reduced.subscribe(function (rs) {
                rs[0].toLowerCase();
            });
        });
    });
});
//# sourceMappingURL=reduce-spec.js.map